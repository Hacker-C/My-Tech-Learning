# 3. 线性表

## 3.1 定义

**线性表**（List）：0个或多个数据元素的有限序列
关键：

1. 有序
2. 有限

```
a1, a2, .., a(i-1), ai, a(i+1), ..., an
```

**前驱与后继**：`a(i-1)` 是 `ai` 的直接前驱元素，`a(i+1)`是`ai` 的直接后继元素。

**线性表的长度**：`n`

**空表**：但 `n = 0` 时，线性表称为空表。 

**位序**：`i`

> 复杂的线性表中，一个数据元素由若干个数据项组成。

## 3.2 线性表的抽象数据类型

ADT

```
ADT List {
		数据对象: D = {ai}
		数据关系: R = <a(i-1), ai>（一对一）
		基本操作: 
				InitList(&L)
						操作结果：构造空表L
				...
				ListLength(L)
						初始条件：L存在
						操作结果：返回线性表长度
} ADT List
```

> 对线性表复杂的操作，由基本操作组成。

## 3.3 线性表的顺序存储结构

### 3.3.1 定义

线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的的数据元素。

### 3.3.2 顺序存储方式

C语言使用一维数组实现顺序存储结构。

<font color=red>数组的长度是指存放线性表的存储空间的长度，线性表的长度是指线性表中数据元素的个数。</font>

任意时刻，线性表的长度要小于等于数组长度。

表长是可以改变的，线性表的基址也是可以改变的；而数组的首址不可变，和长度不可变。

### 3.3.3 顺序表（SqList）地址计算方法

```
LOC(a(i+1)) = LOC(ai) + L
LOC(a(i)) = LOC(a1) + (i - 1) * L
```

> L 是线性表中一个数据元素所占的储存空间大小。

### 3.3.4 顺序存储结构的插入与删除

+ 获得元素操作

  + 插入元素操作

  1. 插入位置不合理，抛出异常；
  2. 表长超过数组长度，抛出异常或动态增加容量；
  3. 从最后一个元素遍历到 `i`，向后移动；
  4. 插入元素到 `i`；
  5. 表长加 `1`。

+ 删除元素操作（`T(n)=O(n) `）

  1. 删除位置不合理，抛出异常；
  2. 取出删除元素；
  3. 从删除位置到最后位置，依次向前移动；
  4. 表长减 `1`。

### 3.3.5 线性表顺序存储结构的优缺点

1. 优点
   + 无需为表示元素的逻辑关系而额外增加空间
   + 快速索引任意位置元素位置
2. 缺点
   + 插入和删除需要移动大量元素
   + 但线性表长度变化较大时，难以确定存储空间大小

## 3.4 线性表的链式存储结构

### 3.4.1 定义

因此，为了表示每个数据元素 `ai` 与其直接后继数据元素`a(i+1)`之间的逻辑关系，对数据元素印来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息 (即直接后继的存储位置)。我们把存储数据元素信息的域称为 **数据域**，把存储直接后继位置的域称为 **指针域**。指针域中存储的信息称做指针或链。这两部分信息组成数据元素ai的存储映像，称为 **结点**（Node)。

### 3.4.2 单链表

n个结点（`ai`的存储映像）链结成一个链表，即为线性表（ai, a2,…，an) 的 链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做 **单链表**。

结点：

+ 数据域：存储数据信息
+ 指针域：存储指针

**头指针**：链表第一个结点的存储位置叫做头指针。

**空指针**：链表最后一个结点指针为空指针（`NULL` 或 `^`）。

**头结点**：为了更好的对链表操作，会在第一个结点前附设一个头结点。

+ 数据域：可以不存储信息；也可以存储线性表的长度等信息。
+ 指针域：指向第一个结点。

**头结点与头指针**：

+ 头指针是链表的必要组成
  + 若无头结点，则头指针指向第一个结点
  + 若有头结点，则头指针指向头结点
+ 头结点是为了更好操作链表，不是必要组成