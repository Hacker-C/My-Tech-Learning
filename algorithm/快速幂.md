快速幂，顾名思义，是一种快速求幂的运算的算法。英文名：Exponentiation by squaring，即平方求幂，时间复杂度为 `O(logn)`，大幅提高时间效率。

# 1. 推导

本人算法菜鸡，前几天刷 leetcode 刷到一道计算 `Pow(x,n)` 的题（[点击前往题目](https://leetcode-cn.com/problems/powx-n/)），一直卡在超时，后来才发现要用到快速幂。

首先来看一个例子。如果要计算 2<sup>20</sup>，最一般的方法是 2\*2，4\*2，...，这样共需计算 19 次，时间复杂度是 `O(n)`。效率很低，包含了大量的重复运算。实际上，我们可以先计算 temp=2<sup>10</sup>，然后计算 temp<sup>2</sup>。这样只需计算 10 次。按照这样的思路，计算 2<sup>10</sup>，也能二分拆成 temp=2<sup>5</sup>，然后计算 temp2<sup>2</sup>...。当遇到奇数次幂的时候，例如 2<sup>5</sup>，则可以划分成 2<sup>4</sup>\*2。直到幂次数变为 n=0。

按照这样的思路，我们可以得出下列的递归公式。

![avatar](https://s3.ax1x.com/2021/01/24/sHI3TA.png)

# 2. 代码实现

由递归公式，我们就可以很容易写出以下递归式快速幂算法。

<font color=red>递归式快速幂</font>

```python
# pyton
def qpow(x, n):
    if n == 0:
        return 1
    elif n % 2 == 0:
        temp = qpow(x, n / 2)
        return temp * temp
    else:
        temp = x * qpow(x, n-1)
```

我们知道，函数递归是要调用栈的，有一定深度限制，需要花费额外空间，所以可以改为递推式。
<font color=red>递推式快速幂</font>

```python
def qpow(x, n):
    ans=1
    while n != 0:
        if n % 2 == 1:
            ans*=x
        x*=x
        n //= 2
    return ans
```

# 3. 优化

需要说明的是，当 n<0 的时候，额外加个判断，取 n 的绝对值计算，最后返回 1/ans 就行。

另外，对于判断 n 的奇偶性，除了通过判断 `n%2==1`，还可以使用 `n&1`，提高时间效率。即：

```python
if n % 2 == 1:
    # n为奇数
```

等价于

```python
if n & 1:
    # n为奇数
```

<font color=red>原理分析</font>

我们知道，按位运算是先转化为二进制数然后每一位进行逻辑运算的。
不难理解，一个十进制奇数转化为一个二进制后，二进制的最后一位必定是 1。即一个十进制奇数转换为二进制数后，会变成 `xxxx xxx1` 的形式。而 1 的二进制数为 `0000 0001`， `xxxx xxx1` & `0000 0001` 的结果是 `0000 0001`，判定其为奇数。反之若 `n&1==0`，则偶数。

可以通过以下例子体会。

```
a = 3(10) = 0000 0011(2)
b = 4(10) = 0000 0100(2)
1(10) = 0000 0001(2)
a & 1 = 1，a为奇数
b & 1 = 0，b为偶数
```

那可能有人会问，那为什么要用位运算？因为在各种运算中，CPU 进行位运算是最快的。将 `%` 替换为 `&` 运算，自然能提高算法时间效率。

# 4. 总结

快速幂的算法，用递推公式来表示很好理解。而递归式的算法很容易就暴栈了，所以一般是改为递推式。

# 声明

本文参考了以下两篇文章
https://zhuanlan.zhihu.com/p/95902286
https://blog.csdn.net/harington/article/details/87602682
