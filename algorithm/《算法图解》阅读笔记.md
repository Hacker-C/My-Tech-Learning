# 《算法图解》阅读笔记

## 1. 二分查找

```python
def binnarySearch(ls:list, item:int)->int:
    low = 0
    high = len(ls) - 1
    while low <= high:
        mid = (low + high) // 2
        if ls[mid] == item:
            return mid
        elif ls[mid] < item:
            low = mid + 1
        else:
            high = mid - 1
    return None
```

+ 时间复杂度：`T(n) = O(logn)`
+ 空间复杂度：`S(n) = O(a)`

## 2. 常见时间复杂度

+ `o(logn)`：对数阶，如二分查找。

+ `O(n)`：线性阶，简单查找。

+ `O(nlogn)`：例如快速排序。

+ `O(n^2)`：如选择排序。

+ `O(n!)`：本书介绍的旅行商问题。

  > 共有n个城市，求旅行商到这个n个地方的距离之和的最小值。

## 3. 简单选择排序

+ 时间复杂度：`O(n^2)`
+ 空间复杂度：`O(n)`
+ 稳定性：

```python
def selectionSort(arr):
    l = len(arr)
    k = 0
    while k < l:
        index = k
        for i in range(k, l):
            if arr[i] < arr[index]:
                index = i
        arr[k], arr[index] = arr[index], arr[k]
        k += 1
    return arr
```

## 4. 递归

### 4.1 递归：

递归两大基本条件：

- 基线条件（base case）
- 递归条件（recursive case）

```python
def recursiveSum(i: int) -> int:
    """
    普通递归
    """
    if i == 1:#基线条件
        return 1
    return i + recursiveSum(i - 1)
```

普通递归函数会产生 **递归调用栈**，而这将花费大量的内存开销。

而栈不能无限调用，当栈调用次数过多，会导致栈溢出。

这时候就需要使用迭代（循环）或者尾递归。

### 4.2 迭代

可以这样理解，迭代就是循环。**循环的过程中将数据不断更新，而内存开销是恒定的。**

```python
def iter(i):
    """
    迭代
    """
    ans = 0
    for j in range(1, i+1):
        ans += j
    return ans
```

### 4.3 尾递归

递归函数多了一个参数，**将变化的参数传递到递归函数中**，这个变化的参数是为上一次函数计算的结果。

**与一般递归不同，尾递归只会占用恒量的内存。**

```python
def tailRecursiveSum(i: int, total=0) -> int:
    """
    尾递归
    """
    if i == 1:
        return total
    return tailRecursiveSum(i - 1, total + i)
```

